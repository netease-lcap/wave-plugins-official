---
description: 从现有代码生成功能规格说明文档
---

## 用户输入

```text
$ARGUMENTS
```

你**必须**在继续之前考虑用户输入（如果不为空）。

## 概述

用户在 `/code2spec` 后输入的文本**应该是**功能模块的描述（如："用户认证模块"）。可选地，用户可以提供代码的具体范围（如："src/auth 目录"）。

假设你在此对话中始终可以访问它，即使下面的 `$ARGUMENTS` 字面出现。除非他们提供了空命令，否则不要要求用户重复。

**重要 - 这是从代码生成规格的命令**: 
- 此命令用于**阅读现有代码**并生成规格说明文档
- **不是**用于根据模糊需求创建规格说明
- 用户需要指定功能模块，你将通过探索代码库找到相关代码
- 如果用户提供了具体的代码路径，优先使用；否则你需要主动搜索相关代码

给定该功能模块描述，执行以下操作：

1. **确定代码范围**: 
   - 检查用户是否提供了功能模块描述
   - 如果 `$ARGUMENTS` 为空，使用 AskUserQuestion 工具询问用户：
     - 他们想要分析哪个功能模块？（如："用户认证"、"支付处理"等）
   - 如果用户提供了具体的代码路径（如："src/auth 目录"），直接使用
   - 如果用户只提供了功能描述，你需要：
     - 使用 Glob 和 Grep 等工具探索代码库
     - 根据功能描述查找相关的文件和目录
     - 确认找到的代码范围是否正确
   - **强调**：这个命令需要阅读**现有代码**，不是根据需求凭空创建规格
   - 只有在确定了要分析的代码后才能继续

2. **生成简短名称**（2-4 个词）作为分支名：
   - 分析功能描述并提取最有意义的关键词
   - 创建一个 2-4 个词的简短名称，捕捉功能的本质
   - 尽可能使用动作-名词格式（例如，"用户认证"、"支付集成"）
   - 保留技术术语和缩写（OAuth2、API、JWT 等）
   - 保持简洁但足够描述性以便一目了然地理解功能
   - 示例：
     - "我想为用户认证功能生成文档" → "用户认证"
     - "为 API 实现 OAuth2 集成" → "oauth2-api集成"
     - "创建分析仪表板" → "分析仪表板"
     - "修复支付处理超时错误" → "支付超时修复"

3. 从仓库根目录运行脚本 `python $WAVE_PLUGIN_ROOT/scripts/create-new-feature.py --json "$ARGUMENTS" --short-name "your-generated-short-name"` 并解析其 JSON 输出以获取 BRANCH_NAME 和 SPEC_FILE。所有文件路径必须是绝对路径。

   **重要**:
   
   - 用步骤 2 中生成的 2-4 个词的简短名称替换 `"your-generated-short-name"`
   - 对于参数中的单引号，如 "I'm Groot"，使用转义语法或双引号："I'm Groot"
   - 你只能运行此脚本一次
   - JSON 在终端中作为输出提供 - 始终参考它以获取你要查找的实际内容

4. **加载模板**:
   - 优先检查当前项目目录下是否存在 `.wave/templates/spec-template.md`。
   - 如果存在，加载该文件作为模板。
   - 如果不存在，加载 `$WAVE_PLUGIN_ROOT/templates/spec-template.md`。
   - 了解所需的部分。

5. **探索和理解代码**:
   
   1. 根据用户指定的模块边界，识别需要阅读的文件和目录
   2. 系统地阅读相关代码文件，理解：
      - 模块的主要功能和职责
      - 关键的类、函数和接口
      - 数据结构和实体
      - 用户交互流程
      - 错误处理和边界情况
   3. 识别关键概念：参与者、操作、数据、约束
   4. 对于不明确的方面：
      - 根据上下文和行业标准做出明智的猜测
      - 仅在以下情况下使用 [需要明确: 具体问题] 标记：
        - 选择会显著影响功能范围或用户体验
        - 存在多种具有不同含义的合理解释
        - 没有合理的默认值
      - **限制：最多总共 3 个 [需要明确] 标记**
      - 按影响优先级排序：范围 > 安全/隐私 > 用户体验 > 技术细节
   5. 填写用户场景和测试部分
      如果没有清晰的用户流程：错误 "无法确定用户场景"
   6. 生成功能需求
      每个需求必须是可测试的
      对未指定的细节使用合理的默认值（在假设部分记录假设）
   7. 识别关键实体（如果涉及数据）
   8. 返回：成功（规格说明准备好进行规划）

6. 使用模板结构将规格说明写入 SPEC_FILE，用从代码分析中得出的具体细节替换占位符，同时保持部分顺序和标题。

7. **规格说明质量验证**：写入初始规格说明后，根据质量标准验证它：

   a. **创建规格说明质量检查清单**：在 `FEATURE_DIR/checklists/requirements.md` 生成检查清单文件，使用以下验证项：
   
      ```markdown
      # 规格说明质量检查清单: [功能名称]
      
      **目的**：在继续规划之前验证规格说明的完整性和质量
      **创建时间**：[日期]
      **功能**：[spec.md 的链接]
      
      ## 内容质量
      
      - [ ] 没有实现细节（语言、框架、API）
      - [ ] 专注于用户价值和业务需求
      - [ ] 为非技术利益相关者编写
      - [ ] 所有必填部分已完成
      
      ## 需求完整性
      
      - [ ] 没有 [需要明确] 标记保留
      - [ ] 需求是可测试和明确的
      - [ ] 所有验收场景都已定义
      - [ ] 已识别边界情况
      - [ ] 范围已明确界定
      - [ ] 已识别依赖和假设
      
      ## 功能就绪性
      
      - [ ] 所有功能需求都有明确的验收标准
      - [ ] 用户场景覆盖主要流程
      - [ ] 规格说明中没有泄露实现细节
      
      ## 备注
      
      - 标记为不完整的项目需要在进行规划之前更新规格说明
      ```
   
   b. **运行验证检查**：根据每个检查清单项检查规格说明：
      - 对于每个项目，确定它是通过还是失败
      - 记录发现的具体问题（引用相关的规格说明部分）
   
   c. **处理验证结果**：
      
      - **如果所有项目都通过**：标记检查清单为完成并继续步骤 8
      
      - **如果项目失败（不包括 [需要明确]）**：
        1. 列出失败的项目和具体问题
        2. 更新规格说明以解决每个问题
        3. 重新运行验证直到所有项目都通过（最多 3 次迭代）
        4. 如果在 3 次迭代后仍然失败，在检查清单备注中记录剩余问题并警告用户
      
      - **如果 [需要明确] 标记保留**：
        1. 从规格说明中提取所有 [需要明确: ...] 标记
        2. **限制检查**：如果存在超过 3 个标记，只保留 3 个最关键的（按范围/安全/用户体验影响）并对其余的做出明智的猜测
        3. 对于每个需要明确的内容（最多 3 个），以此格式向用户呈现选项：
        
           ```markdown
           ## 问题 [N]：[主题]
           
           **上下文**：[引用相关的规格说明部分]
           
           **我们需要知道的**：[需要明确标记中的具体问题]
           
           **建议答案**：
           
           | 选项 | 答案 | 影响 |
           |------|------|------|
           | A    | [第一个建议答案] | [这对功能意味着什么] |
           | B    | [第二个建议答案] | [这对功能意味着什么] |
           | C    | [第三个建议答案] | [这对功能意味着什么] |
           | 自定义 | 提供你自己的答案 | [解释如何提供自定义输入] |
           
           **你的选择**：_[等待用户响应]_
           ```
        
        4. **关键 - 表格格式**：确保 markdown 表格格式正确：
           - 使用一致的间距，管道符号对齐
           - 每个单元格应该在内容周围有空格：`| 内容 |` 而不是 `|内容|`
           - 标题分隔符必须至少有 3 个破折号：`|--------|`
           - 在 markdown 预览中测试表格是否正确呈现
        5. 按顺序编号问题（Q1、Q2、Q3 - 最多 3 个）
        6. 在等待响应之前一起呈现所有问题
        7. 等待用户响应所有问题的选择（例如，"Q1: A, Q2: 自定义 - [详细信息], Q3: B"）
        8. 通过用用户选择或提供的答案替换每个 [需要明确] 标记来更新规格说明
        9. 解决所有明确问题后重新运行验证
   
   d. **更新检查清单**：在每次验证迭代后，使用当前的通过/失败状态更新检查清单文件

8. 报告完成情况，包括分支名称、规格说明文件路径、检查清单结果以及下一阶段的准备情况（进一步完善或规划）。

**注意**：脚本在写入之前创建并检出新分支并初始化规格说明文件。

## 一般指南

## 快速指南

- 关注用户**需要什么**和**为什么**。
- 避免如何实现（没有技术栈、API、代码结构）。
- 为业务利益相关者编写，而不是开发人员。
- 不要创建嵌入在规格说明中的任何检查清单。那将是一个单独的命令。

### 部分要求

- **必填部分**：每个功能都必须完成
- **可选部分**：仅在与功能相关时包含
- 当部分不适用时，完全删除它（不要留下 "N/A"）

### 用于 AI 生成

从代码创建此规格说明时：

1. **做出明智的猜测**：使用上下文、行业标准和常见模式来填补空白
2. **记录假设**：在假设部分记录合理的默认值
3. **限制明确**：最多 3 个 [需要明确] 标记 - 仅用于关键决策：
   - 显著影响功能范围或用户体验
   - 有多种具有不同含义的合理解释
   - 缺乏任何合理的默认值
4. **优先级明确**：范围 > 安全/隐私 > 用户体验 > 技术细节
5. **像测试人员一样思考**：每个模糊的需求都应该无法通过 "可测试和明确" 的检查清单项
6. **需要明确的常见领域**（仅在没有合理默认值时）：
   - 功能范围和边界（包括/排除特定用例）
   - 用户类型和权限（如果可能有多种相互冲突的解释）
   - 安全/合规要求（当在法律/财务上重要时）
   
**合理默认值示例**（不要询问这些）：

- 数据保留：该领域的行业标准做法
- 性能目标：标准 Web/移动应用期望，除非另有说明
- 错误处理：用户友好的消息和适当的回退
- 认证方法：对于 Web 应用，标准的基于会话或 OAuth2
- 集成模式：RESTful API，除非另有说明
